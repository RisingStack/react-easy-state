{"version":3,"sources":["App.tsx","index.tsx","../../src/utils.js","../../src/queue.js","../../src/view.js","../../src/store.js","../../src/scheduler.js"],"names":["store","s","name","setNameEvent","ev","target","this","value","App","v","greeting","children","htmlFor","id","onChange","bind","ReactDOM","render","document","getElementById","globalObj","window","global","hasHooks","queue","constructor","task","isInsideFunctionComponent","isInsideClassComponentRender","isInsideFunctionComponentWithoutHooks","COMPONENT","Symbol","TRIGGERRENDER","view","Comp","isStatelessComp","ReactiveComp","props","useState","triggerRender","useCallback","setState","useMemo","observe","scheduler","lazy","useEffect","unobserve","BaseComp","state","keys","Object","nextKeys","key","nextProps","stores","component","mapStateToStores","memo","obj","observable","Error","batch","fn","ctx","args","result","cache","batchFn","batched","batchMethodsCallbacks","methods","method","descriptor","Proxy","apply","Reflect","batchMethodCallbacks","Promise","EventTarget","WebSocket","batchMethods","newDescriptor","set","batchMethod"],"mappings":"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","file":"static/js/main.c910b7b7.chunk.js","sourcesContent":["import React, { ChangeEvent } from 'react';\nimport { view as v, store as s } from 'react-easy-state';\n\nconst store = s({\n  name: 'Peter',\n  setNameEvent(ev: ChangeEvent<HTMLInputElement>) {\n    if (ev.target) {\n      this.name = ev.target.value;\n    }\n  },\n});\n\n// properly retain these props for the views\ntype AppProps = {\n  greeting: string;\n};\n\nconst App: React.FC<AppProps> = v(({ greeting, children }) => (\n  <div>\n    <h1>\n      {greeting} {store.name}!\n    </h1>\n    <label htmlFor=\"name\">Name:</label>\n    <input\n      id=\"name\"\n      value={store.name}\n      onChange={store.setNameEvent.bind(store)}\n    />\n    {children}\n  </div>\n));\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <App greeting=\"Hello\" />,\n  document.getElementById('root'),\n);\n","import { useState } from 'react';\n\n// try to find the global object\n// it is window in the DOM and global in NodeJS and React Native\nconst isDOM = typeof window !== 'undefined';\nconst isNative = typeof global !== 'undefined';\nexport const globalObj = isDOM\n  ? window\n  : isNative\n  ? global\n  : undefined;\n\nexport const hasHooks = typeof useState === 'function';\n","class Queue {\n  constructor() {\n    this.taskSet = new Set();\n    this.isInsideBatch = false;\n  }\n\n  add = task => {\n    if (this.isInsideBatch) {\n      this.taskSet.add(task);\n    } else {\n      task();\n    }\n  };\n\n  flush = () => {\n    if (this.taskSet.size !== 0) {\n      this.taskSet.forEach(task => task());\n      this.taskSet.clear();\n    }\n  };\n\n  on = () => {\n    this.isInsideBatch = true;\n  };\n\n  off = () => {\n    this.isInsideBatch = false;\n  };\n}\n\nexport const queue = new Queue();\n","import {\n  Component,\n  useState,\n  useEffect,\n  useMemo,\n  memo,\n  useCallback,\n} from 'react';\nimport {\n  observe,\n  unobserve,\n  raw,\n  isObservable,\n} from '@nx-js/observer-util';\n\nimport { hasHooks } from './utils';\nimport { queue } from './queue';\n\nexport let isInsideFunctionComponent = false;\nexport let isInsideClassComponentRender = false;\nexport let isInsideFunctionComponentWithoutHooks = false;\nconst COMPONENT = Symbol('owner component');\nconst TRIGGERRENDER = Symbol('trigger render');\n\nfunction mapStateToStores(state) {\n  // find store properties and map them to their none observable raw value\n  // to do not trigger none static this.setState calls\n  // from the static getDerivedStateFromProps lifecycle method\n  const component = state[COMPONENT];\n  return Object.keys(component)\n    .map(key => component[key])\n    .filter(isObservable)\n    .map(raw);\n}\n\nexport function view(Comp) {\n  const isStatelessComp = !(\n    Comp.prototype && Comp.prototype.isReactComponent\n  );\n\n  let ReactiveComp;\n\n  if (isStatelessComp && hasHooks) {\n    // use a hook based reactive wrapper when we can\n    ReactiveComp = props => {\n      // use a dummy setState to update the component\n      const [, setState] = useState();\n      const triggerRender = useCallback(() => setState({}), []);\n      // create a memoized reactive wrapper of the original component (render)\n      // at the very first run of the component function\n      const render = useMemo(\n        () =>\n          observe(Comp, {\n            scheduler: () => queue.add(triggerRender),\n            lazy: true,\n          }),\n        // Adding the original Comp here is necessary to make React Hot Reload work\n        // it does not affect behavior otherwise\n        [Comp],\n      );\n\n      // cleanup the reactive connections after the very last render of the component\n      useEffect(() => {\n        return () => unobserve(render);\n      }, []);\n\n      // the isInsideFunctionComponent flag is used to toggle `store` behavior\n      // based on where it was called from\n      isInsideFunctionComponent = true;\n      try {\n        // run the reactive render instead of the original one\n        return render(props);\n      } finally {\n        isInsideFunctionComponent = false;\n      }\n    };\n  } else {\n    const BaseComp = isStatelessComp ? Component : Comp;\n    // a HOC which overwrites render, shouldComponentUpdate and componentWillUnmount\n    // it decides when to run the new reactive methods and when to proxy to the original methods\n    class ReactiveClassComp extends BaseComp {\n      constructor(props, context) {\n        super(props, context);\n\n        this.state = this.state || {};\n        this.state[COMPONENT] = this;\n\n        // create a reactive render for the component\n        this.render = observe(this.render, {\n          scheduler: () => queue.add(this[TRIGGERRENDER]),\n          lazy: true,\n        });\n      }\n\n      [TRIGGERRENDER] = () => {\n        this.setState({});\n      };\n\n      render() {\n        isInsideClassComponentRender = !isStatelessComp;\n        isInsideFunctionComponentWithoutHooks = isStatelessComp;\n        try {\n          return isStatelessComp\n            ? Comp(this.props, this.context)\n            : super.render();\n        } finally {\n          isInsideClassComponentRender = false;\n          isInsideFunctionComponentWithoutHooks = false;\n        }\n      }\n\n      // react should trigger updates on prop changes, while easyState handles store changes\n      shouldComponentUpdate(nextProps, nextState) {\n        const { props, state } = this;\n\n        // respect the case when the user defines a shouldComponentUpdate\n        if (super.shouldComponentUpdate) {\n          return super.shouldComponentUpdate(nextProps, nextState);\n        }\n\n        // return true if it is a reactive render or state changes\n        if (state !== nextState) {\n          return true;\n        }\n\n        // the component should update if any of its props shallowly changed value\n        const keys = Object.keys(props);\n        const nextKeys = Object.keys(nextProps);\n        return (\n          nextKeys.length !== keys.length ||\n          nextKeys.some(key => props[key] !== nextProps[key])\n        );\n      }\n\n      // add a custom deriveStoresFromProps lifecyle method\n      static getDerivedStateFromProps(props, state) {\n        if (super.deriveStoresFromProps) {\n          // inject all local stores and let the user mutate them directly\n          const stores = mapStateToStores(state);\n          super.deriveStoresFromProps(props, ...stores);\n        }\n        // respect user defined getDerivedStateFromProps\n        if (super.getDerivedStateFromProps) {\n          return super.getDerivedStateFromProps(props, state);\n        }\n        return null;\n      }\n\n      componentWillUnmount() {\n        // call user defined componentWillUnmount\n        if (super.componentWillUnmount) {\n          super.componentWillUnmount();\n        }\n        // clean up memory used by Easy State\n        unobserve(this.render);\n      }\n    }\n\n    ReactiveComp = ReactiveClassComp;\n  }\n\n  ReactiveComp.displayName = Comp.displayName || Comp.name;\n  // static props are inherited by class components,\n  // but have to be copied for function components\n  if (isStatelessComp) {\n    Object.keys(Comp).forEach(key => {\n      ReactiveComp[key] = Comp[key];\n    });\n  }\n\n  return isStatelessComp && hasHooks\n    ? memo(ReactiveComp)\n    : ReactiveComp;\n}\n","import { useMemo } from 'react';\nimport { observable } from '@nx-js/observer-util';\n\nimport {\n  isInsideFunctionComponent,\n  isInsideClassComponentRender,\n  isInsideFunctionComponentWithoutHooks,\n} from './view';\n\nexport function store(obj) {\n  // do not create new versions of the store on every render\n  // if it is a local store in a function component\n  // create a memoized store at the first call instead\n  if (isInsideFunctionComponent) {\n    return useMemo(() => observable(obj), []);\n  }\n  if (isInsideFunctionComponentWithoutHooks) {\n    throw new Error(\n      'You cannot use state inside a function component with a pre-hooks version of React. Please update your React version to at least v16.8.0 to use this feature.',\n    );\n  }\n  if (isInsideClassComponentRender) {\n    throw new Error(\n      'You cannot use state inside a render of a class component. Please create your store outside of the render function.',\n    );\n  }\n  return observable(obj);\n}\n","/* eslint camelcase: 0 */\n\nimport { globalObj } from './utils';\nimport { queue } from './queue';\n\n// this runs the passed function and delays all re-renders\n// until the function is finished running\nexport function batch(fn, ctx, args) {\n  let result;\n  if (queue.isInsideBatch) {\n    result = fn.apply(ctx, args);\n  } else {\n    try {\n      queue.on();\n      result = fn.apply(ctx, args);\n    } finally {\n      queue.flush();\n      queue.off();\n    }\n  }\n  return result;\n}\n\n// this creates and returns a batched version of the passed function\n// the cache is necessary to always map the same thing to the same function\n// which makes sure that addEventListener/removeEventListener pairs don't break\nconst cache = new WeakMap();\nfunction batchFn(fn) {\n  if (typeof fn !== 'function') {\n    return fn;\n  }\n  let batched = cache.get(fn);\n  if (!batched) {\n    batched = function(...args) {\n      return batch(fn, this, args);\n    };\n    cache.set(fn, batched);\n  }\n  return batched;\n}\n\nfunction batchMethodCallbacks(obj, method) {\n  const descriptor = Object.getOwnPropertyDescriptor(obj, method);\n  if (\n    descriptor &&\n    descriptor.writable &&\n    typeof descriptor.value === 'function'\n  ) {\n    obj[method] = new Proxy(descriptor.value, {\n      apply(target, ctx, args) {\n        return Reflect.apply(target, ctx, args.map(batchFn));\n      },\n    });\n  }\n}\n\n// batched obj.addEventListener(cb) like callbacks\nfunction batchMethodsCallbacks(obj, methods) {\n  methods.forEach(method => batchMethodCallbacks(obj, method));\n}\n\nfunction batchMethod(obj, method) {\n  const descriptor = Object.getOwnPropertyDescriptor(obj, method);\n  if (descriptor && descriptor.configurable) {\n    const newDescriptor = {\n      ...descriptor,\n      set(value) {\n        return descriptor.set.call(this, batchFn(value));\n      },\n    };\n    Object.defineProperty(obj, method, newDescriptor);\n  }\n}\n\n// batches obj.onevent = fn like calls\nfunction batchMethods(obj, methods) {\n  methods.forEach(method => batchMethod(obj, method));\n}\n\n// do a sync batching for the most common task sources\n// this should be removed when React's own batching is improved in the future\n\n// batch timer functions\nbatchMethodsCallbacks(globalObj, [\n  'setTimeout',\n  'setInterval',\n  'requestAnimationFrame',\n  'requestIdleCallback',\n]);\n\nif (globalObj.Promise) {\n  batchMethodsCallbacks(Promise.prototype, ['then', 'catch']);\n}\n\n// batch addEventListener calls\nif (globalObj.EventTarget) {\n  batchMethodsCallbacks(EventTarget.prototype, [\n    'addEventListener',\n    'removeEventListener',\n  ]);\n}\n\n// this batches websocket event handlers\nif (globalObj.WebSocket) {\n  batchMethods(WebSocket.prototype, [\n    'onopen',\n    'onmessage',\n    'onerror',\n    'onclose',\n  ]);\n}\n\n// HTTP event handlers are usually wrapped by Promises, which is covered above\n"],"sourceRoot":""}